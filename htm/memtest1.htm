<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
	<head>
		<title></title>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
		<meta content="Microsoft FrontPage 4.0" name="GENERATOR">
	</head>
	<body bgColor="#ffffff">
		<p>AleGr MEMTEST is a program for testing DRAM (main memory) of PC-compatible 
			computers built on Intel 386 or higher processor. The version 2.0 is now able 
			to run under Windows.</p>
		<P>Some of older programs for memory testing were written for cacheless processors 
			and required to disable the cache, when used on modern computers.&nbsp; This 
			program is designed to run on the processors with memory cache, and takes into 
			account how&nbsp;the system bus, cache and main memory of Pentium and Pentium 
			Pro (Pentium II, III, 4) processors work. Test patterns and access sequences 
			used by the program are designed to test burst transfers between CPU and L2 
			cache and/or memory, because such transfers occur most of the time in real 
			applications. It also tests some special access cycles, such as locked 
			read-modify-write.</P>
		<P>Maximum size of memory the program is able to test is 3 gigabytes under DOS and 
			less than 2 gigabytes under Windows. If you have 4 GB or more, you can start 
			several test sessions under Windows, to cover all the memory.</P>
		<p>The program can be run under "bare" DOS session, and under Windows 98, Windows 
			ME, Windows 2000, Windows XP. It may work under Windows NT 4.0 as well, but has 
			never been tested.</p>
		<P>The program runs differently under DOS and Windows.</P>
		<H3 align="center">Licence terms</H3>
		<P align="left">The MEMTEST version 2.0 program is free for personal (non-business) 
			use. For business use, send email to <A href="mailto:alegr@earthlink.net">alegr@earthlink.net</A> 
			for information about buing a license and support. Source code can also be 
			purchased.</P>
		<P align="left">WARNING: There is no guarantee of any kind. On some low-power 
			systems, the program may cause excessive current consumption, and trigger 
			overcurrent protection or cause permanent damage. When the program is run under 
			Windows, it can cause a marginally stable&nbsp;system to crash with possible 
			loss of data or OS damage.</P>
		<H3 align="center">Running the program under "bare" DOS</H3>
		<P>"Bare" DOS means&nbsp;"real mode" DOS without any memory managers, such as 
			HIMEM.SYS and EMM386.EXE. Version 2.0 can now start if HIMEM.SYS is present.</P>
		<P><STRONG>If you run Windows 95:</STRONG></P>
		<P>To start a bare DOS session, restart the computer and press <font face="Times New Roman">
				<kbd>Shift+F5</kbd></font> when "<strong>Starting Windows 95...</strong>" 
			message appears. You can also boot from a floppy.</FONT>
		</P>
		<P><STRONG>If you run Windows&nbsp;98:</STRONG></P>
		<P>For Windows 98 bare DOS session, press and hold <kbd>Ctrl</kbd> when OS begins 
			booting (just after BIOS detected all disk drives). Windows 98 boot menu will 
			appear. Press <font face="Times New Roman"><kbd>Shift+F5</kbd> to start DOS. You 
				can also boot from a floppy.</font></P>
		<P><STRONG>If you run Windows ME:</STRONG></P>
		<P>Windows ME doesn't allow to boot into DOS directly. You can use a boot floppy, 
			but&nbsp;you will need to use <STRONG>/ignorexmm</STRONG> (or <STRONG>/ig</STRONG>) 
			command line option.</P>
		<P><STRONG>If you run Windows 2000 or XP:</STRONG></P>
		<P>Windows 2000 and XP cannot boot into DOS. You will need to boot from a floppy. 
			You can create a boot disk when you format a floppy. You may need to use 
			/ignorexmm command line switch when you start the program.</P>
		<p>Command line to start the program is as follows:</p>
		<p><font face="Times New Roman"><samp><strong>MEMTEST &lt;memory size&gt; &lt;base address of 
						area to test&gt; /program switches</strong></samp></font></p>
		<p>Optional <strong>memory size</strong> and <strong>base address </strong>of an 
			area to test are specified in megabytes. If they are not specified, all 
			available memory&nbsp;will be tested.&nbsp;Since the program detects actual 
			memory size, it is safe to specify more memory than actually installed.</p>
		<p>The program cannot test less than 8 megabytes.</p>
		<p>The following command line&nbsp;switches are recognized (they can be abbreviated 
			down to the part shown with <U>underscore</U>):</p>
		<p>/<U>ro</U>w:&lt;size&gt; - specifies size (in kilobytes) of DRAM memory array 
			row. Allowed values are 4 up to 64 (only powers of 2). By default all possible 
			row sizes from 4 to 64 are tested. Specify this option only if you exactly know 
			row size (it depends on memory chip manufacturer and model and is <STRONG>not</STRONG>
			usually published even in memory data sheets). If specified size does not match 
			real value, the program won't be able to test the memory chips for maximum 
			noise on word lines.</p>
		<p>/<U>de</U>lay &lt;time1&gt; &lt;time2&gt; - specifies the delay (in seconds) 
			between memory write and read passes. The delay specified by <strong>time1</strong>
			is inserted on every other test pass, default value is 1 second. The delay 
			specified by <strong>time2 </strong>is inserted on 62th and 63th passes of 64, 
			default is 60 seconds. This allows to test for proper DRAM refresh.</p>
		<p>/<U>sp</U>eed - tells the program to measure CPU clock rate and also L2 cache 
			and main memory read/write speed (including write in write-allocate mode);</p>
		<p>/<U>re</U>adtwice - tells the program to compare test data twice;</p>
		<p>/<U>wr</U>itethru - disables writeback cache policy;</p>
		<p>/<U>noca</U>che - disables cache at all (not recommended).</p>
		<P>/<U>nopr</U>efetch - doesn't perform cache prefetch.</P>
		<P>/<U>noch</U>eck - disables machine check on Pentium (and newer) systems. Machine 
			check interrupt is triggered when bus or cache parity error occurs.</P>
		<p>/<U>pre</U>heat - the program will try to preheat the memory chips by the 
			special access sequence, before writing each test pattern. Remember, though, 
			that using this option on some notebook computers may trigger overcurrent 
			protection.
		</p>
		<p>/<U>nous</U>blegacy - disables USB legacy emulation interrupt. Use it when the 
			test shows memory errors in the very first kilobyte of physical memory. If this 
			switch doesn't help, run the test starting from megabyte 1, for example: "<STRONG>MEMTEST 
				512 1</STRONG>".
		</p>
		<p>/<U>fa</U>stdetect - use fast memory size detection algorithm (though less 
			thorough).
		</p>
		<P>/<U>ig</U>norexmm - run the program even though XMM (HIMEM.SYS) is detected. Is 
			necessary is you use Windows ME boot floppy.</P>
		<P>/<U>nola</U>rgepages - do not use 4MB pages. Use regular 4KB pages only.</P>
		<P>/<U>pat</U>tern:&lt;pattern1&gt;:&lt;pattern2&gt; - sets a pair of special 
			32-bit patterns. &lt;pattern1&gt; and &lt;pattern2&gt; are specified in 
			hexadecimal notation, for example: /pat:01234567:FEDCBA98. Each value is 
			duplicated to form a 64-bit quad-word, so the memory will be written with the 
			following data pattern:</P>
		<P><FONT face="Courier New">01234567<FONT face="Courier New">01234567<BR>
					FEDCBA98FEDCBA98<BR>
					<FONT face="Courier New">01234567<FONT face="Courier New">01234567<BR>
							FEDCBA98FEDCBA98</FONT></FONT></FONT></FONT></P>
		<P>After testing the complete memory, the pattern is rotated, and it is repeated 
			until the pattern returns to the original value.</P>
		<P>Once MEMTEST is started, it is not possible to return back to DOS,&nbsp;because 
			the program switches the CPU to 32-bit protected mode. Testing can only be 
			stopped by the system restart - either by pressing <font face="Times New Roman"><kbd>Ctrl+Alt+Del</kbd></font>
			or by pressing <font face="Times New Roman"><kbd>Reset</kbd></font> (it can be 
			found on the system case, not on the keyboard), or by turning the power off 
			then off (recommended only for the systems without <font face="Times New Roman"><kbd>Reset</kbd></font>
			button).</P>
		<P>If the program detects less memory than you know is installed, it probably means 
			that a piece of very unstable memory is detected and the program decided to 
			stop scanning for more.</P>
		<p>When memory errors messages fill all the screen, the program pauses screen 
			output to prevent error messages loss. To resume the output, press <font face="Times New Roman">
				<kbd>Enter</kbd></font>.</p>
		<p>While the program is working, it displays the test pass number. Full test 
			consists of 64 passes. Required time depends on CPU and memory size. Keep in 
			mind that every other test pass includes 36 seconds of delay and two passes of 
			64 both include 36 minutes of delay. <STRONG>After the program completed all 64 
				passes, it will continue to run the test from the beginning. To stop the test, 
				you need to restart the computer, by pressing Ctrl+Alt+Del.</STRONG></p>
		<H3 align="center">Running the program under Windows</H3>
		<P align="left">This capability was added to provide more realistic testing of the 
			overall system stability.
		</P>
		<P align="left">Under Windows, the program starts a few threads running in 
			parallel, each testing its own region of virtual addresses. It can also run 
			disk read/write test, to check if disk DMA operations could cause the memory 
			corruption.</P>
		<P align="left">Disk I/O test&nbsp;has been added because:
		</P>
		<UL>
			<LI>
				<DIV align="left">there are known IDE RAID controller chipsets&nbsp;that suffer 
					from data corruption during&nbsp;simultaneous data transfer on both IDE 
					channels under Windows 2000 and Linux,&nbsp;when overall throughput of IDE 
					interface exceeds PCI bus throughput. Probably the controller could not 
					properly arbitrate requests from its own channels in case of contention.</DIV>
			<LI>
				<DIV align="left">a mainboard in my computer was suffering from memory corruption 
					(some bits were unstable) during heavy disk I/O. The computer was crashing 
					whenever I tried to copy about 10 GB of files. The problem never showed up in 
					DOS-based MEMTEST run, but the new test could catch the error in a couple of 
					minutes. DIMM and CPU replacement didn't help. A new board with the same 
					chipset (though slightly different modification - without on-chip video 
					controller), but from different OEM, works fine. I don't know&nbsp;whether it 
					was the board layout problem, or some PCB traces had defects.
				</DIV>
			</LI>
		</UL>
		<P>Under Windows, the test log can be saved to a file.</P>
		<P>Command line to start the program is as follows:</P>
		<P><FONT face="Times New Roman"><SAMP><STRONG>MEMTEST&nbsp;&lt;program switches&gt;</STRONG></SAMP></FONT></P>
		<P>The following command line switches are recognized:</P>
		<P>/<U>ti</U>me:&lt;time limit&gt; - sets test time in minutes. If you don't 
			specify this option, the default test time is 60 minutes;</P>
		<P>/<U>mem</U>ory:&lt;n&gt; - specifies the test area size in megabytes, from 4 to 
			1024. Up to 4 <STRONG>/memory</STRONG> command line switches allowed, each of 
			them causes the program to start a separate test thread. /pattern option that 
			goes after /memory specifies a test pattern for this thread. Max total allowed 
			memory size is about 2000 MB. If you&nbsp;need to test&nbsp;more memory, you 
			can start more test sessions.</P>
		<P>/<U>fi</U>le:&lt;directory&gt; &lt;n&gt; - specifies the test&nbsp;file location 
			and&nbsp;size in megabytes (from 4 up to 64000).&nbsp;Up to 4 <STRONG>/file</STRONG>
			command line switches allowed,&nbsp;each of them causes the program to start a 
			separate test thread. /pattern option that goes after /file specifies a test 
			pattern for this thread. If the directory name contains spaces, surround it 
			with double quote characters. The directory should exist before the program is 
			run.</P>
		<P>/<U>maxe</U>rrors:&lt;n&gt; - maximum number of errors before the test stops. 
			The test runs until time specified by /time switch elapses, or maximum number 
			of errors found;</P>
		<P>/<U>re</U>adtwice - tells the program to compare test data twice;</P>
		<P>/<U>noca</U>che - disables cache at all (not recommended).</P>
		<P>/<U>pre</U>heat - the program will try to preheat the memory chips by the 
			special access sequence, before writing each test pattern. Remember, though, 
			that using this option on some notebook computers may trigger overcurrent 
			protection.
		</P>
		<P>/<U>log</U>file:&lt;file name&gt; - writes a test log to the file. If the '+' 
			character precedes the file name, test log will be appended to the file. The 
			log&nbsp;file is always opened with write-through option, which prevents loss 
			of the messages if the system crashes.</P>
		<P>/<U>pat</U>tern:&lt;pattern1&gt;:&lt;pattern2&gt; - sets a pair of 32-bit test 
			patterns. &lt;pattern1&gt; and &lt;pattern2&gt; are specified in hexadecimal 
			notation, for example: /pat:01234567:FEDCBA98. Each value is duplicated to form 
			a 64-bit quad-word, so the memory will be written with the following data 
			pattern:</P>
		<P><FONT face="Courier New">01234567<FONT face="Courier New">01234567<BR>
					FEDCBA98FEDCBA98<BR>
					<FONT face="Courier New">01234567<FONT face="Courier New">01234567<BR>
							FEDCBA98FEDCBA98</FONT></FONT></FONT></FONT></P>
		<P>After&nbsp;writing/reading the complete test area, the pattern is rotated (right 
			shift by one bit), and&nbsp;the test repeats.&nbsp;The pass is completed 
			when&nbsp;the pattern returns to the original value.</P>
		<P>Each memory or file test thread can have its own test pattern. For example:</P>
		<P>MEMTEST /mem:64 /pat:01234567:FEDCBA98 /mem:64 /pat:80008000:7FFF7FFF
			<BR>
			&nbsp;&nbsp; /file:c:\ 256 /pat:80007FFF:7FFF8000&nbsp; /file:d:\ 256 
			/pat:0080FF7F:0080FF7F</P>
		<P>For file test, it makes sense to use patterns which are inverted every 16 bits, 
			like 80007FFF. It is because the IDE data bus is 16 bits wide. For SCSI 
			disk,&nbsp;different test pattern may be better, for example inverted every 8 
			bits for 8-bit SCSI bus.</P>
		<P>It is recommended that different test threads use different test patterns.</P>
		<P>To avoid disk thrashing, use one file test per physical drive. If you're running 
			a RAID disk array, use one thread per controller channel, although the disks 
			will experience continuous thrashing.</P>
		<P>Check if you're specified not too much memory to test. Open Task Manager 
			(Ctrl+Shift+Esc) and on the Performance tab see if the CPU is fully loaded. If 
			it is not, then there is memory paging (see also the hard drive light), and you 
			need to reduce test area size.</P>
		<P>The test can be stopped by pressing either Ctrl+Break or Ctrl+C. It may not stop 
			immediately, though.</P>
		<hr>
		<p align="center"><font size="4">Memory test sequence</font></p>
		<p align="left"><font size="3">First test performs pseudorandom data read/write. The 
				data consists of "all ones"/"all zeros" patterns produced by pseudorandom 
				sequence generator. The test checks for address errors.</font></p>
		<p align="left"><font size="3">The second test uses a pair of 32-bit patterns. Each 
				pattern is duplicated to form a 64-bit quadword. These quadwords are written 
				each after other:</font></p>
		<FONT size="3">
			<P align="left"><FONT face="Times New Roman"><CODE>01111111111111110111111111111111 
						01111111111111110111111111111111<BR>
						10000000000000001000000000000000 10000000000000001000000000000000<BR>
						01111111111111110111111111111111 01111111111111110111111111111111<BR>
						10000000000000001000000000000000 10000000000000001000000000000000</CODE></FONT></P>
			<P align="left">The test patterns can be specified in the program command line. The 
				default pattern is running zero/running one pair, like shown above. This test 
				sequence allows also to check the system bus in maximum noise conditions.
			</P>
			<P align="left">
		</FONT>After all the memory being tested is filled with the pattern, it is read 
		in ascenting direction (from address 0 to the highest address) and compared 
		with reference data. As the memory is read, the data is replaced with inverted 
		test pattern. After all the memory is read and replaced with inverted pattern, 
		it is read in descenting direction and compared with new reference data. As the 
		memory is read, the data is replaced with next test pattern, which is like 
		first one cyclically shifted (rotated) to right:</P>
		<p><font face="Times New Roman"><code>1011111111111111 1011111111111111 1011111111111111 
					1011111111111111<br>
					0100000000000000 0100000000000000 0100000000000000 0100000000000000<br>
					1011111111111111 1011111111111111 1011111111111111 1011111111111111<br>
					0100000000000000 0100000000000000 0100000000000000 0100000000000000</code></font></p>
		<p>Pattern replacement on the descenting pass is done with&nbsp;uncacheable 64-bit 
			exchange operation: CMPEXCH8B. This allows to test locked read-modify-write 
			memory cycle.</p>
		<P>Such tests are performed for all bit positions (total 16).</P>
		<P>Next tests work with "all ones"/"all zeros" patterns, with pattern inverted on 
			every other memory array row. This test exploits the dynamic RAM structure.</P>
		<p>Dynamic RAM array is crossed by <strong>word</strong> (or row) lines (that go 
			from row address decoder) and column lines. Each pair of column lines is 
			connected to differential inputs of read detector. Even rows are connected to 
			even column lines, and odd rows are connected to odd lines. Column lines are 
			connected also to reference cells that are charged to half voltage of a regular 
			cell. When, for instance, even row is selected, memory cells are read to even 
			column lines and reference cells are read to odd column lines. Voltage 
			difference (tens of millivolts) is detected by read detectors and converted to 
			logical 0 or 1. Then read cells are charged back to full voltage (refreshed) 
			and row is deselected. After that, all column lines should be discharged to 
			fixed voltage level, it is called "RAS precharge".</p>
		<p>Maximum noise to column lines occures when all cells are charged to same "low" 
			or "high" state, this means that adjacent rows should be written with inverted 
			data. To achieve this, test pattern is inverted every 4 to 64 KB (step is 
			doubled on every test pass), and data is read from interlaced rows - 32 bytes 
			from one row, 32 bytes from adjacent one. "All zeros" and "all ones" patterns 
			allow also to induce maxium noise on adjacent column lines.</p>
		<p>When running in a standalone mode, the program relocates itself in the physical 
			memory after every test pass, to test the area it just occupied.</p>
		<P>In a standalone mode, every other pass includes 1 second delay between memory 
			writing and reading. During the delay there are no accesses to the DRAM, 
			because all instructions are fetched from the L1 cache. This allows to check 
			how reliable is memory refresh. On two passes from 64 the delay is increased to 
			60 seconds. These delays can be specified in the command line at the program 
			start.</P>
		<P>When running under Windows, the program decommits the memory area after every 
			pass, it means releases the physical pages. It allows to test different pages 
			every time.</P>
		<p>To test transfers from L2 cache to the processor, some of test passes are 
			performed with data prefetched from the memory to L2 cache. Without such 
			prefetch, the data goes directly from memory to the processor. To test 
			transfers from processor to L2 cache, some of the test passes are performed 
			with data prefetched to L2 cache during test pattern write.</p>
		<H3 align="center">File test sequence</H3>
		<P align="left">To test file transfers, a temporary file (named TstXX.tmp) is 
			created. Test file location and size (in megabytes from 4 to 640000) is 
			specified in<STRONG> /file</STRONG> command line option. The program can run 
			simultaneous read/write&nbsp;up to four&nbsp;files. The files are opened with 
			file cache disabled.</P>
		<P align="left">The file is first written with the specified pattern. The default 
			initial pattern pair is 7FFF8000/80007FFF. The file is then read and compared 
			with the pattern. In case of a mismatch, an error message is logged.</P>
		<P align="left">The pattern is then cyclically shifted (rotated), each 16-bit word 
			individually. For example 7FFF8000 becomes DFFF4000. This pattern is also 
			written and verified. It repeats until the pattern returns to the original 
			value.</P>
		<H3 align="center">Changes history</H3>
		<p align="left">2.00 (August 1,&nbsp;2002). Fixed a bug in memory speed test. Added 
			capability to work under Windows. Removed default memory size limit in 512 
			megabytes.</p>
		<P align="left">1.04 (August 10, 2000). Fixed a bug in the test relocation, which 
			caused it to reboot on machines with more than 960 MB of memory. Added /<b>nousblegacy</b>
			and /<b>fastdetect</b> command line options.</P>
		<p align="left">1.03 (March 28, 1999). Fixed a bug in timer function in V1.02, 
			which was caused by compiler upgrade to MSVC 5.0. Added <strong>/preheat</strong>
			command line option.</p>
		<p align="left">1.02 (Feb 25, 1999). Fixed i386 and i486 processor detection. Fixed 
			problem with Intel P-II motherboards, which caused the test to reboot a 
			computer. Added <strong>/nocheck</strong> command line option to disable 
			machine check interrupt on P5 and P6 processors.</p>
		<p>1.01 (Jan 22, 1998). Changed way to reset CPU for reboot. Instead of putting the 
			CPU to shutdown mode (did not work on Pentium Pro+FX440) reset by keyboard 
			controller is used. Added reset of floppy drives' motors before going to 
			protected mode.</p>
		<p>1.0 (Dec 30, 1997). First released.</p>
		<P>&nbsp;</P>
	</body>
</html>
